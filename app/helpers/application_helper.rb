module ApplicationHelper

  # Interpret a string as markdown
  # @param text the text in markdown format
  # @returns an interpreted html_safe string representation of text
  def markdown(text)
    unless defined?(@@markdown)
      parse_options = {autolink: true, underline: true, hightlight: true, strikethrough: true, tables: true, no_intra_emphasis: true, fenced_code_blocks: true, disable_indented_code_blocks: true}
      renderer_options = {escape_html: true, hard_wrap: true, prettify: true}
      renderer = Redcarpet::Render::HTML.new(renderer_options)
      @@markdown = Redcarpet::Markdown.new(renderer, parse_options)
    end
    @@markdown.render(text).html_safe
  end

  # Display either yes or no highlighted in green or red
  # @param value the boolean value being represented
  # @param positive_value (optional, default true) the value to be considered positive (and displayed in green)
  # @returns an HTML safe string
  def yes_no(value, positive_value=true)
    if positive_value == value
      return "<span style=\"color: green;\">#{value ? 'yes' : 'no'}</span>".html_safe
    else
      return "<span style=\"color: red;\">#{value ? 'YES' : 'NO'}</span>".html_safe
    end
  end

  # Display text highlighted in green or red
  # @param value the boolean value being represented
  # @param positive_value (optional, default true) the value to be considered positive (and displayed in green)
  # @param text the text to display
  # @returns an HTML safe string
  def pos_neg(value, positive_value=true, text)
    if positive_value == value
      return "<span style=\"color: green;\">#{text}</span>".html_safe
    else
      return "<span style=\"color: red;\">#{text}</span>".html_safe
    end
  end

  # Get the date in the chosen format with the day of the month ordinalized
  # @param date the time to display in the format
  # @param format_string the format string to pass to the strftime methods, after replacing %d with the ordinalized day of the month
  # @returns a string representing the date
  def ordinalized_date(date, format_string)
    return date.strftime(format_string.gsub(/\%d/, date.strftime('%e').to_i.ordinalize.to_s))
  end

  # Convert a time to duration to finish a sentance fragment starting "do this by"
  # @param time the time to convert to words 
  # @returns a string
  def do_by_time(time)
    if time.today?
      return time.strftime('%H:%M today')
    end
    if time.to_date == Date.tomorrow
      return time.strftime('%H:%M tomorrow')
    end
    if time.to_date <= (Date.today + 6.days)
      return time.strftime('%H:%M on %A')
    end
    return ordinalized_date(time, '%H:%M on %A %d %B')
  end

  # Create a link for sorting a table by a given column from the model
  # @param column a string identifying the column to sort by
  # @param title (optional) the column title to use in the link, f not provided the title is generated from column
  # @returns a link generated by the link_to helper
  def sortable_link(column, title=nil)
    css_class = 'sortable'
    title ||= column.titleize
    css_class += (column == sort_column) ? " sortable_current sortable_#{sort_direction}" : ''
    direction = ((column == sort_column) && sort_direction == "asc") ? "desc" : "asc"
    link_to title, params.merge({:sort_column => column, :sort_direction => direction, :page => nil}), {:class => css_class}
  end


  def div_for_password_strength_meter
    %q{<div id="password_strength_meter" style="display: inline-block; min-width: 215px; font-weight: bold; color: black; background-color: #7777ff;">No password!</div>}.html_safe
  end


  # Set title for the page and insert an H1 tag
  def page_title(title)
    provide :title, title
    content_tag 'h1', title
  end


  # Convert an array of (string or array of string) into a set of li tags for display to the user
  def html_from_log_lines(lines)
    content_tag :ol do
      lines.each do |line|
        next line if line.empty?
        if line.is_a?(Array)
          concat html_from_log_lines(line)
        else
          concat content_tag(:li, line)
        end
      end # each line
    end # content_tag :ol
  end

  # Convert an array of (string or array of string) into a set of bulleted lines
  def text_from_log_lines(lines, level=0)
    output = ''
    bullets = "*+>-"
    lines.each do |line|
      next line if line.empty?
      if line.is_a?(Array)
        output += text_from_log_lines(line, level+1)
      else
        output += ' ' * (4 * level)
        output += bullets[level % bullets.size] + ' '
        output += line
        output += "\n"
      end     
    end # each line
    return output
  end

  def stylesheet_link_tag_if_exists(path, opts = {})
    if Rails.application.assets.find_asset("#{path}.css")
      stylesheet_link_tag(path, opts)
    end
  end

  def javascript_include_tag_if_exists(path, opts = {})
    if Rails.application.assets.find_asset("#{path}.js")
      javascript_include_tag(path, opts)
    end
  end

end
